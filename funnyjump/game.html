<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gra Platformowa</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #333;
            display: none;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        #menu h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            color: #4169E1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        #menu p {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
        }
        #playButton {
            font-size: 24px;
            padding: 15px 50px;
            background: linear-gradient(to bottom, #4169E1, #1E4DB7);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(65, 105, 225, 0.4);
            transition: all 0.3s ease;
        }
        #playButton:hover {
            background: linear-gradient(to bottom, #5179F1, #2E5DC7);
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(65, 105, 225, 0.6);
        }
        #playButton:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(65, 105, 225, 0.4);
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>Gra Platformowa</h1>
        <p>Sterowanie: ‚Üê ‚Üí - ruch, SPACJA - skok, PRAWY SHIFT - kucanie</p>
        <p>UWA≈ªAJ NA DZIURY!</p>
        <button id="playButton">GRAJ</button>
    </div>
    <div class="controls">
        <h3>Sterowanie:</h3>
        <p>‚Üê ‚Üí - ruch w lewo/prawo, SPACJA - skok, 2x SPACJA - wysoki skok</p>
        <p>PRAWY SHIFT - kucanie (blokuje skok, zwalnia ruch)</p>
        <p>UWA≈ªAJ NA DZIURY! Wpadniesz = 3s parali≈º (r√≥≈ºowy kolor)</p>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const game = {
            player: {
                x: 50,
                y: 280,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 5,
                jumpPower: 15,
                highJumpPower: 20,
                onGround: false,
                canDoubleJump: false,
                animFrame: 0,
                stunned: false,
                stunTime: 0,
                originalColor: '#4169E1',
                lastSafeX: 50,
                lastSafeY: 280,
                crouching: false,
                originalHeight: 60
            },
            obstacles: [],
            holes: [],
            clouds: [],
            butterflies: [],
            bees: [],
            mountains: [],
            flowers: [],
            portal: null,
            spiders: [],
            camera: {
                x: 0
            },
            keys: {},
            spacePressed: false,
            spaceReleased: true,
            jumpCount: 0,
            lastJumpTime: 0,
            started: false,
            lives: 3,
            level: 1,
            portalAnimationPhase: 0
        };

        function createObstacles() {
            const obstacles = [];
            const holes = [];

            // Difficulty scaling by level
            const levelConfig = {
                1: { count: 25, spacing: 180, holeChance: 0.85, highChance: 0.75, barrierChance: 0.6, spikeChance: 0.5 },
                2: { count: 35, spacing: 150, holeChance: 0.82, highChance: 0.72, barrierChance: 0.58, spikeChance: 0.48 },
                3: { count: 45, spacing: 130, holeChance: 0.80, highChance: 0.70, barrierChance: 0.56, spikeChance: 0.46 },
                4: { count: 55, spacing: 110, holeChance: 0.78, highChance: 0.68, barrierChance: 0.54, spikeChance: 0.44 }
            };

            const config = levelConfig[game.level] || levelConfig[4];
            const obstacleCount = config.count;

            for (let i = 0; i < obstacleCount; i++) {
                const x = 300 + i * config.spacing + Math.random() * 50;
                const rand = Math.random();

                const holeChance = config.holeChance;
                const highChance = config.highChance;
                const barrierChance = config.barrierChance;
                const spikeChance = config.spikeChance;

                if (rand > holeChance) {
                    const holeWidth = 60 + (game.level - 1) * 5; // Wider holes on higher levels
                    holes.push({
                        x: x,
                        y: 340,
                        width: holeWidth,
                        height: 60,
                        type: 'hole'
                    });
                } else if (rand > highChance) {
                    const wallHeight = 90 + (game.level - 1) * 5; // Taller walls
                    obstacles.push({
                        x: x,
                        y: 340 - wallHeight,
                        width: 30,
                        height: wallHeight,
                        type: 'high',
                        color: '#8B0000'
                    });
                } else if (rand > barrierChance) {
                    // Lower barriers should be high enough to crouch under
                    // Player when crouching is at y=304 with height=36 (60*0.6)
                    // So barrier bottom should be at least at y=304 or higher
                    obstacles.push({
                        x: x,
                        y: 260,  // Raised from 240 to 260
                        width: 80,
                        height: 55,  // Reduced from 75 to 55
                        type: 'lowBarrier',
                        color: '#B8860B'
                    });
                } else if (rand > spikeChance) {
                    const spikeWidth = 25 + (game.level - 1) * 5; // Wider spikes
                    obstacles.push({
                        x: x,
                        y: 310,
                        width: spikeWidth,
                        height: 30,
                        type: 'spikes',
                        color: '#FF4500'
                    });
                } else if (rand > 0.3) {
                    obstacles.push({
                        x: x,
                        y: 280,
                        width: 40,
                        height: 60,
                        type: 'block',
                        color: '#654321'
                    });
                } else {
                    const moveSpeed = 0.05 + (game.level - 1) * 0.015; // Faster moving obstacles
                    obstacles.push({
                        x: x,
                        y: 290,
                        width: 35,
                        height: 50,
                        type: 'moving',
                        color: '#9932CC',
                        originalY: 290,
                        moveSpeed: moveSpeed
                    });
                }
            }
            game.holes = holes;

            // Create spiders on level 3+ (new trap!)
            if (game.level >= 3) {
                const spiders = [];
                const spiderCount = game.level === 3 ? 6 : 10;

                for (let i = 0; i < spiderCount; i++) {
                    const spiderX = 700 + i * 500 + Math.random() * 150;
                    const dropHeight = 100 + Math.random() * 80;
                    spiders.push({
                        x: spiderX,
                        y: 50,
                        targetY: 50,
                        width: 25,
                        height: 25,
                        maxDrop: dropHeight,
                        speed: 1.5 + (game.level - 3) * 0.5,
                        state: 'waiting', // waiting, dropping, rising
                        webLength: 0,
                        waitTime: Math.random() * 100
                    });
                }
                game.spiders = spiders;
            } else {
                game.spiders = [];
            }

            // Create portal at the end
            const lastObstacleX = Math.max(...obstacles.map(o => o.x), ...holes.map(h => h.x));
            game.portal = {
                x: lastObstacleX + 300,
                y: 240,
                width: 60,
                height: 100
            };

            return obstacles;
        }

        function createClouds() {
            const clouds = [];
            for (let i = 0; i < 15; i++) {
                clouds.push({
                    x: Math.random() * 4000,
                    y: 20 + Math.random() * 80,
                    width: 60 + Math.random() * 40,
                    height: 30 + Math.random() * 20,
                    speed: 0.2 + Math.random() * 0.3
                });
            }
            return clouds;
        }

        function spawnButterfly() {
            game.butterflies.push({
                x: -50,
                y: 50 + Math.random() * 100,
                speed: 1 + Math.random() * 1.5,
                wingPhase: Math.random() * Math.PI * 2,
                bobPhase: Math.random() * Math.PI * 2,
                color: ['#FF69B4', '#FFD700', '#9370DB', '#FF4500', '#32CD32'][Math.floor(Math.random() * 5)]
            });
        }

        function spawnBee() {
            game.bees.push({
                x: -30,
                y: 150 + Math.random() * 150,
                speed: 2 + Math.random() * 1,
                wingPhase: Math.random() * Math.PI * 2,
                bobPhase: Math.random() * Math.PI * 2,
                targetFlower: null,
                flowerTime: 0
            });
        }

        function createMountains() {
            const mountains = [];
            for (let i = 0; i < 8; i++) {
                mountains.push({
                    x: i * 200 - 100,
                    y: 150 + Math.random() * 50,
                    width: 300 + Math.random() * 100,
                    height: 150 + Math.random() * 100,
                    color: i % 2 === 0 ? '#8B7D6B' : '#A0907A'
                });
            }
            return mountains;
        }


        function createFlowers() {
            const flowers = [];
            const colors = [
                '#FF1493', '#FF69B4', '#FFB6C1', '#FFC0CB',
                '#FF6347', '#FF4500', '#FF8C00', '#FFA500',
                '#FFD700', '#FFFF00', '#ADFF2F', '#7FFF00',
                '#32CD32', '#00FF00', '#90EE90', '#98FB98',
                '#9370DB', '#8A2BE2', '#9932CC', '#BA55D3',
                '#FF0000', '#DC143C', '#B22222', '#CD5C5C',
                '#00BFFF', '#1E90FF', '#4169E1', '#6495ED',
                '#FF1493', '#FFB6C1', '#DDA0DD', '#E6E6FA'
            ];
            
            for (let i = 0; i < 100; i++) {
                flowers.push({
                    x: Math.random() * 4000,
                    y: 340 + Math.random() * 15,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: 3 + Math.random() * 2,
                    swayPhase: Math.random() * Math.PI * 2
                });
            }
            return flowers;
        }

        function resetLevel() {
            // Reset player position
            game.player.x = 50;
            game.player.y = 280;
            game.player.velocityX = 0;
            game.player.velocityY = 0;
            game.player.onGround = false;
            game.player.stunned = false;
            game.player.stunTime = 0;
            game.player.crouching = false;
            game.player.height = game.player.originalHeight;
            game.player.lastSafeX = 50;
            game.player.lastSafeY = 280;

            // Reset camera
            game.camera.x = 0;

            // Reset lives to full
            game.lives = 3;

            // Reset keys
            game.keys = {};
            game.jumpCount = 0;

            // Regenerate obstacles for current level
            game.obstacles = createObstacles();
            game.clouds = createClouds();
            game.mountains = createMountains();
            game.flowers = createFlowers();
            game.butterflies = [];
            game.bees = [];
        }

        game.obstacles = createObstacles();
        game.clouds = createClouds();
        game.mountains = createMountains();
        game.flowers = createFlowers();

        function handleInput() {
            if (game.player.stunned) {
                game.player.velocityX = 0;
                return;
            }
            
            // Handle crouching
            if (game.keys['ShiftRight']) {
                if (!game.player.crouching) {
                    game.player.crouching = true;
                    game.player.y += game.player.originalHeight - game.player.originalHeight * 0.6; // Move down
                    game.player.height = game.player.originalHeight * 0.6; // Reduce height
                }
            } else {
                if (game.player.crouching) {
                    game.player.crouching = false;
                    game.player.y -= game.player.originalHeight - game.player.originalHeight * 0.6; // Move up
                    game.player.height = game.player.originalHeight; // Restore height
                }
            }
            
            // Slower movement while crouching
            const currentSpeed = game.player.crouching ? game.player.speed * 0.5 : game.player.speed;
            
            if (game.keys['ArrowRight']) {
                game.player.velocityX = currentSpeed;
            } else if (game.keys['ArrowLeft']) {
                game.player.velocityX = -currentSpeed;
            } else {
                game.player.velocityX = 0;
            }

            if (game.keys[' '] && game.spaceReleased && !game.player.crouching) {
                const currentTime = Date.now();
                
                if (currentTime - game.lastJumpTime < 300) {
                    if (game.jumpCount === 1) {
                        game.player.velocityY = -game.player.jumpPower * 0.7;
                        game.jumpCount = 2;
                    }
                } else {
                    if (game.player.onGround) {
                        game.player.velocityY = -game.player.jumpPower;
                        game.jumpCount = 1;
                        game.lastJumpTime = currentTime;
                    }
                }
                game.spaceReleased = false;
            }

            if (!game.keys[' ']) {
                game.spaceReleased = true;
            }
        }

        function updatePlayer() {
            handleInput();
            
            if (game.player.stunned) {
                game.player.stunTime -= 16;
                if (game.player.stunTime <= 0) {
                    game.player.stunned = false;
                }
                return;
            }

            game.player.velocityY += 0.8;
            game.player.x += game.player.velocityX;
            game.player.y += game.player.velocityY;

            if (game.player.y >= 280) {
                game.player.y = 280;
                game.player.velocityY = 0;
                game.player.onGround = true;
                game.jumpCount = 0;
                
                let isOverHole = false;
                for (let hole of game.holes) {
                    if (game.player.x + game.player.width/2 >= hole.x &&
                        game.player.x + game.player.width/2 <= hole.x + hole.width) {
                        isOverHole = true;
                        break;
                    }
                }
                
                if (!isOverHole) {
                    game.player.lastSafeX = game.player.x;
                    game.player.lastSafeY = game.player.y;
                }
            } else {
                game.player.onGround = false;
            }

            if (game.player.x < 0) {
                game.player.x = 0;
            }

            game.player.animFrame += 0.2;
            
            for (let obstacle of game.obstacles) {
                if (obstacle.type === 'moving') {
                    obstacle.y = obstacle.originalY + Math.sin(Date.now() * obstacle.moveSpeed) * 20;
                }
            }

            for (let cloud of game.clouds) {
                cloud.x += cloud.speed;
                if (cloud.x > game.camera.x + canvas.width + 100) {
                    cloud.x = game.camera.x - cloud.width - 100;
                }
            }

            for (let i = game.butterflies.length - 1; i >= 0; i--) {
                let butterfly = game.butterflies[i];
                butterfly.x += butterfly.speed;
                butterfly.wingPhase += 0.4;
                butterfly.bobPhase += 0.1;
                butterfly.y += Math.sin(butterfly.bobPhase) * 0.5;
                
                if (butterfly.x > game.camera.x + canvas.width + 50) {
                    game.butterflies.splice(i, 1);
                }
            }

            if (Math.random() < 0.0008) {
                spawnButterfly();
            }

            for (let i = game.bees.length - 1; i >= 0; i--) {
                let bee = game.bees[i];
                
                if (!bee.targetFlower || bee.flowerTime <= 0) {
                    bee.x += bee.speed;
                    bee.wingPhase += 0.6;
                    bee.bobPhase += 0.15;
                    bee.y += Math.sin(bee.bobPhase) * 0.8;
                    
                    const nearbyFlower = game.flowers.find(flower => 
                        Math.abs(flower.x - bee.x) < 100 && Math.abs(flower.y - bee.y) < 80
                    );
                    
                    if (nearbyFlower && Math.random() < 0.02) {
                        bee.targetFlower = nearbyFlower;
                        bee.flowerTime = 60 + Math.random() * 120;
                    }
                } else {
                    const dx = bee.targetFlower.x - bee.x;
                    const dy = bee.targetFlower.y - bee.y;
                    bee.x += dx * 0.05;
                    bee.y += dy * 0.05;
                    bee.wingPhase += 0.8;
                    bee.flowerTime--;
                    
                    if (bee.flowerTime <= 0) {
                        bee.targetFlower = null;
                    }
                }
                
                if (bee.x > game.camera.x + canvas.width + 50) {
                    game.bees.splice(i, 1);
                }
            }

            if (Math.random() < 0.0005) {
                spawnBee();
            }

            for (let flower of game.flowers) {
                flower.swayPhase += 0.02;
            }

            // Update spiders
            for (let spider of game.spiders) {
                if (spider.state === 'waiting') {
                    spider.waitTime--;
                    if (spider.waitTime <= 0) {
                        // Check if player is nearby
                        const distanceToPlayer = Math.abs(game.player.x - spider.x);
                        if (distanceToPlayer < 200) {
                            spider.state = 'dropping';
                        } else {
                            spider.waitTime = 60;
                        }
                    }
                } else if (spider.state === 'dropping') {
                    spider.y += spider.speed;
                    spider.webLength = spider.y - 50;

                    if (spider.y >= 50 + spider.maxDrop) {
                        spider.state = 'rising';
                    }
                } else if (spider.state === 'rising') {
                    spider.y -= spider.speed * 0.7;
                    spider.webLength = spider.y - 50;

                    if (spider.y <= 50) {
                        spider.y = 50;
                        spider.state = 'waiting';
                        spider.waitTime = 120 + Math.random() * 60;
                        spider.webLength = 0;
                    }
                }
            }

            // Update portal animation
            game.portalAnimationPhase += 0.05;
        }

        function checkCollisions() {
            if (game.player.stunned) return;
            
            const playerRect = {
                x: game.player.x,
                y: game.player.y,
                width: game.player.width,
                height: game.player.height
            };

            for (let obstacle of game.obstacles) {
                const obstacleRect = {
                    x: obstacle.x,
                    y: obstacle.y,
                    width: obstacle.width,
                    height: obstacle.height
                };

                if (playerRect.x < obstacleRect.x + obstacleRect.width &&
                    playerRect.x + playerRect.width > obstacleRect.x &&
                    playerRect.y < obstacleRect.y + obstacleRect.height &&
                    playerRect.y + playerRect.height > obstacleRect.y) {
                    
                    // Special handling for low barriers - only collide if not crouching
                    if (obstacle.type === 'lowBarrier') {
                        if (!game.player.crouching) {
                            game.player.x = obstacleRect.x - game.player.width;
                            game.player.velocityX = 0;
                            break;
                        }
                        // If crouching, allow passage - no collision
                    } else {
                        // Normal collision for other obstacles
                        game.player.x = obstacleRect.x - game.player.width;
                        game.player.velocityX = 0;
                        break;
                    }
                }
            }
            
            for (let hole of game.holes) {
                if (playerRect.x + playerRect.width/2 >= hole.x &&
                    playerRect.x + playerRect.width/2 <= hole.x + hole.width &&
                    playerRect.y + playerRect.height >= hole.y) {

                    game.lives--;

                    if (game.lives <= 0) {
                        // Reset current level only (not entire game)
                        resetLevel();
                    } else {
                        // Lose life but continue
                        game.player.x = game.player.lastSafeX;
                        game.player.y = game.player.lastSafeY;
                        game.player.velocityX = 0;
                        game.player.velocityY = 0;
                        game.player.stunned = true;
                        game.player.stunTime = 3000;
                    }
                    break;
                }
            }

            // Check spider collision
            for (let spider of game.spiders) {
                const spiderRect = {
                    x: spider.x - spider.width/2,
                    y: spider.y - spider.height/2,
                    width: spider.width,
                    height: spider.height
                };

                if (playerRect.x < spiderRect.x + spiderRect.width &&
                    playerRect.x + playerRect.width > spiderRect.x &&
                    playerRect.y < spiderRect.y + spiderRect.height &&
                    playerRect.y + playerRect.height > spiderRect.y) {

                    game.lives--;

                    if (game.lives <= 0) {
                        // Reset current level
                        resetLevel();
                    } else {
                        // Lose life but continue
                        game.player.x = game.player.lastSafeX;
                        game.player.y = game.player.lastSafeY;
                        game.player.velocityX = 0;
                        game.player.velocityY = 0;
                        game.player.stunned = true;
                        game.player.stunTime = 3000;
                    }
                    break;
                }
            }

            // Check portal collision
            if (game.portal) {
                const portalRect = {
                    x: game.portal.x,
                    y: game.portal.y,
                    width: game.portal.width,
                    height: game.portal.height
                };

                if (playerRect.x < portalRect.x + portalRect.width &&
                    playerRect.x + playerRect.width > portalRect.x &&
                    playerRect.y < portalRect.y + portalRect.height &&
                    playerRect.y + playerRect.height > portalRect.y) {

                    // Enter portal - go to next level with full lives
                    if (game.level < 4) {
                        game.level++;
                        resetLevel();
                    } else {
                        // Level 4 completed - show victory and restart from level 1
                        alert('üéâ GRATULACJE! Uko≈Ñczy≈Çe≈õ wszystkie 4 poziomy! üéâ\n\nGra zaczyna siƒô od poczƒÖtku.');
                        game.level = 1;
                        resetLevel();
                    }
                }
            }
        }

        function updateCamera() {
            const targetCameraX = game.player.x - 200;
            game.camera.x = Math.max(0, targetCameraX);
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            const playerColor = game.player.stunned ? '#FF69B4' : game.player.originalColor;
            const bobOffset = game.player.crouching ? 0 : Math.sin(game.player.animFrame) * 3;
            const armSwing = game.player.crouching ? Math.sin(game.player.animFrame * 1.5) * 2 : Math.sin(game.player.animFrame * 1.5) * 4;
            const legSwing = game.player.crouching ? 0 : Math.sin(game.player.animFrame * 1.2) * 5;
            const crouchOffset = game.player.crouching ? 15 : 0;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(game.player.x + 10, game.player.y + 1 + crouchOffset, 20, 12);
            
            ctx.fillStyle = '#FFDBAC';
            ctx.beginPath();
            ctx.arc(game.player.x + 20, game.player.y + 12 + crouchOffset, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(game.player.x + 16, game.player.y + 8 + bobOffset + crouchOffset, 3, 0, Math.PI * 2);
            ctx.arc(game.player.x + 24, game.player.y + 8 + bobOffset + crouchOffset, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(game.player.x + 16, game.player.y + 8 + bobOffset + crouchOffset, 2, 0, Math.PI * 2);
            ctx.arc(game.player.x + 24, game.player.y + 8 + bobOffset + crouchOffset, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(game.player.x + 16, game.player.y + 8 + bobOffset + crouchOffset, 1, 0, Math.PI * 2);
            ctx.arc(game.player.x + 24, game.player.y + 8 + bobOffset + crouchOffset, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.arc(game.player.x + 20, game.player.y + 14 + crouchOffset, 2, 0, Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#FFDBAC';
            ctx.beginPath();
            ctx.arc(game.player.x + 20, game.player.y + 18 + crouchOffset, 3, Math.PI, 0);
            ctx.fill();
            
            ctx.fillStyle = playerColor;
            ctx.beginPath();
            if (game.player.crouching) {
                ctx.roundRect(game.player.x + 12, game.player.y + 22 + crouchOffset, 16, 18, 8);
            } else {
                ctx.roundRect(game.player.x + 12, game.player.y + 22, 16, 25, 8);
            }
            ctx.fill();
            
            ctx.fillStyle = '#FFDBAC';
            ctx.beginPath();
            ctx.arc(game.player.x + 8 + armSwing/2, game.player.y + 28 + armSwing + crouchOffset, 3, 0, Math.PI * 2);
            ctx.arc(game.player.x + 32 - armSwing/2, game.player.y + 28 - armSwing + crouchOffset, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = playerColor;
            ctx.beginPath();
            if (game.player.crouching) {
                ctx.roundRect(game.player.x + 5 + armSwing/2, game.player.y + 25 + armSwing + crouchOffset, 6, 12, 3);
                ctx.roundRect(game.player.x + 29 - armSwing/2, game.player.y + 25 - armSwing + crouchOffset, 6, 12, 3);
            } else {
                ctx.roundRect(game.player.x + 5 + armSwing/2, game.player.y + 25 + armSwing, 6, 15, 3);
                ctx.roundRect(game.player.x + 29 - armSwing/2, game.player.y + 25 - armSwing, 6, 15, 3);
            }
            ctx.fill();
            
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            if (game.player.crouching) {
                // Legs bent when crouching
                ctx.roundRect(game.player.x + 13, game.player.y + 40 + crouchOffset, 6, 10, 3);
                ctx.roundRect(game.player.x + 21, game.player.y + 40 + crouchOffset, 6, 10, 3);
            } else {
                ctx.roundRect(game.player.x + 13, game.player.y + 47 + legSwing, 6, 13, 3);
                ctx.roundRect(game.player.x + 21, game.player.y + 47 - legSwing, 6, 13, 3);
            }
            ctx.fill();
            
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            if (game.player.crouching) {
                ctx.roundRect(game.player.x + 11, game.player.y + 48 + crouchOffset, 10, 4, 2);
                ctx.roundRect(game.player.x + 19, game.player.y + 48 + crouchOffset, 10, 4, 2);
            } else {
                ctx.roundRect(game.player.x + 11, game.player.y + 58 + legSwing, 10, 4, 2);
                ctx.roundRect(game.player.x + 19, game.player.y + 58 - legSwing, 10, 4, 2);
            }
            ctx.fill();
            
            if (game.player.stunned) {
                ctx.fillStyle = '#FF1493';
                ctx.font = '14px Arial';
                ctx.fillText('STUNNED!', game.player.x - 5, game.player.y - 10);
            }
            
            ctx.restore();
        }

        function drawObstacles() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            for (let obstacle of game.obstacles) {
                if (obstacle.x + obstacle.width > game.camera.x && 
                    obstacle.x < game.camera.x + canvas.width) {
                    
                    if (obstacle.type === 'spikes') {
                        const gradient = ctx.createLinearGradient(0, obstacle.y, 0, obstacle.y + obstacle.height);
                        gradient.addColorStop(0, '#C0C0C0');
                        gradient.addColorStop(0.3, '#A0A0A0');
                        gradient.addColorStop(1, '#808080');
                        
                        ctx.fillStyle = gradient;
                        for (let i = 0; i < obstacle.width; i += 4) {
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + i, obstacle.y + obstacle.height);
                            ctx.lineTo(obstacle.x + i + 2, obstacle.y);
                            ctx.lineTo(obstacle.x + i + 4, obstacle.y + obstacle.height);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.strokeStyle = '#666';
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    } else if (obstacle.type === 'high') {
                        const brickGradient = ctx.createLinearGradient(0, obstacle.y, 0, obstacle.y + obstacle.height);
                        brickGradient.addColorStop(0, '#CD853F');
                        brickGradient.addColorStop(0.5, '#8B4513');
                        brickGradient.addColorStop(1, '#654321');
                        
                        ctx.fillStyle = brickGradient;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        ctx.strokeStyle = '#4A2C2A';
                        ctx.lineWidth = 1;
                        for (let row = 0; row < Math.floor(obstacle.height / 15); row++) {
                            const y = obstacle.y + row * 15;
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x, y);
                            ctx.lineTo(obstacle.x + obstacle.width, y);
                            ctx.stroke();
                            
                            for (let col = 0; col < Math.floor(obstacle.width / 20); col++) {
                                const x = obstacle.x + col * 20 + (row % 2) * 10;
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + 15);
                                ctx.stroke();
                            }
                        }
                    } else if (obstacle.type === 'block') {
                        const rockGradient = ctx.createRadialGradient(
                            obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/3, 0,
                            obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, obstacle.width/2
                        );
                        rockGradient.addColorStop(0, '#A9A9A9');
                        rockGradient.addColorStop(0.7, '#696969');
                        rockGradient.addColorStop(1, '#2F2F2F');
                        
                        ctx.fillStyle = rockGradient;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + 5, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + 2, obstacle.y + obstacle.height * 0.7);
                        ctx.lineTo(obstacle.x + 8, obstacle.y + obstacle.height * 0.3);
                        ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width - 8, obstacle.y + obstacle.height * 0.3);
                        ctx.lineTo(obstacle.x + obstacle.width - 2, obstacle.y + obstacle.height * 0.7);
                        ctx.lineTo(obstacle.x + obstacle.width - 5, obstacle.y + obstacle.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width - 8, obstacle.y + obstacle.height * 0.3);
                        ctx.lineTo(obstacle.x + obstacle.width - 2, obstacle.y + obstacle.height * 0.7);
                        ctx.lineTo(obstacle.x + obstacle.width - 5, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height * 0.8);
                        ctx.closePath();
                        ctx.fill();
                    } else if (obstacle.type === 'lowBarrier') {
                        // Draw wooden log barrier
                        const logGradient = ctx.createLinearGradient(0, obstacle.y, 0, obstacle.y + obstacle.height);
                        logGradient.addColorStop(0, '#DAA520');
                        logGradient.addColorStop(0.3, '#B8860B');
                        logGradient.addColorStop(0.7, '#8B6914');
                        logGradient.addColorStop(1, '#654321');
                        
                        ctx.fillStyle = logGradient;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // Wood grain lines
                        ctx.strokeStyle = 'rgba(139, 69, 19, 0.4)';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            const y = obstacle.y + obstacle.height * (0.2 + i * 0.3);
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x, y);
                            ctx.lineTo(obstacle.x + obstacle.width, y);
                            ctx.stroke();
                        }
                        
                        // Vertical grain
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 4; i++) {
                            const x = obstacle.x + obstacle.width * (0.15 + i * 0.25);
                            ctx.beginPath();
                            ctx.moveTo(x, obstacle.y);
                            ctx.lineTo(x, obstacle.y + obstacle.height);
                            ctx.stroke();
                        }
                        
                        // Metal brackets on ends
                        ctx.fillStyle = '#A9A9A9';
                        ctx.fillRect(obstacle.x - 2, obstacle.y + obstacle.height * 0.2, 4, obstacle.height * 0.6);
                        ctx.fillRect(obstacle.x + obstacle.width - 2, obstacle.y + obstacle.height * 0.2, 4, obstacle.height * 0.6);
                        
                        // Bracket screws
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(obstacle.x, obstacle.y + obstacle.height * 0.3, 1, 0, Math.PI * 2);
                        ctx.arc(obstacle.x, obstacle.y + obstacle.height * 0.7, 1, 0, Math.PI * 2);
                        ctx.arc(obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.3, 1, 0, Math.PI * 2);
                        ctx.arc(obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.7, 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Support posts
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(obstacle.x + 10, obstacle.y + obstacle.height, 6, 30);
                        ctx.fillRect(obstacle.x + obstacle.width - 16, obstacle.y + obstacle.height, 6, 30);
                        
                    } else if (obstacle.type === 'moving') {
                        const crystalGradient = ctx.createLinearGradient(0, obstacle.y, 0, obstacle.y + obstacle.height);
                        crystalGradient.addColorStop(0, '#E6E6FA');
                        crystalGradient.addColorStop(0.3, '#9370DB');
                        crystalGradient.addColorStop(0.7, '#8A2BE2');
                        crystalGradient.addColorStop(1, '#4B0082');
                        
                        ctx.fillStyle = crystalGradient;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.3);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.6, obstacle.y + obstacle.height * 0.2);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.4, obstacle.y + obstacle.height * 0.5);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.3, obstacle.y + obstacle.height * 0.2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            
            for (let hole of game.holes) {
                if (hole.x + hole.width > game.camera.x && 
                    hole.x < game.camera.x + canvas.width) {
                    
                    const centerX = hole.x + hole.width/2;
                    const centerY = hole.y + hole.height/2;
                    const baseRadius = hole.width/2;
                    
                    // Create irregular hole shape using multiple overlapping circles
                    if (!hole.irregularPoints) {
                        hole.irregularPoints = [];
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            const radiusVariation = 0.7 + Math.random() * 0.6; // 0.7 to 1.3
                            hole.irregularPoints.push({
                                angle: angle,
                                radius: baseRadius * radiusVariation
                            });
                        }
                    }
                    
                    // Draw shadow/ground displacement around hole
                    ctx.fillStyle = 'rgba(101, 67, 33, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(centerX + hole.irregularPoints[0].radius * Math.cos(hole.irregularPoints[0].angle) * 1.3, 
                              centerY + hole.irregularPoints[0].radius * Math.sin(hole.irregularPoints[0].angle) * 1.3);
                    for (let i = 1; i < hole.irregularPoints.length; i++) {
                        const point = hole.irregularPoints[i];
                        ctx.lineTo(centerX + point.radius * Math.cos(point.angle) * 1.3, 
                                  centerY + point.radius * Math.sin(point.angle) * 1.3);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw rocks and debris around hole edge
                    if (!hole.rocks) {
                        hole.rocks = [];
                        for (let i = 0; i < 8 + Math.random() * 6; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = baseRadius * (1.1 + Math.random() * 0.4);
                            hole.rocks.push({
                                x: centerX + Math.cos(angle) * distance,
                                y: centerY + Math.sin(angle) * distance,
                                size: 1 + Math.random() * 3,
                                color: Math.random() > 0.5 ? '#8B7D6B' : '#654321'
                            });
                        }
                    }
                    
                    // Draw small rocks
                    for (let rock of hole.rocks) {
                        ctx.fillStyle = rock.color;
                        ctx.beginPath();
                        ctx.arc(rock.x, rock.y, rock.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Rock highlight
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.beginPath();
                        ctx.arc(rock.x - rock.size * 0.3, rock.y - rock.size * 0.3, rock.size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Draw grass around hole edge
                    if (!hole.grassBlades) {
                        hole.grassBlades = [];
                        for (let i = 0; i < 15 + Math.random() * 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = baseRadius * (0.9 + Math.random() * 0.4);
                            hole.grassBlades.push({
                                x: centerX + Math.cos(angle) * distance,
                                y: centerY + Math.sin(angle) * distance,
                                height: 3 + Math.random() * 4,
                                lean: (Math.random() - 0.5) * 0.5,
                                color: ['#228B22', '#32CD32', '#2E8B57'][Math.floor(Math.random() * 3)]
                            });
                        }
                    }
                    
                    // Draw grass blades
                    for (let grass of hole.grassBlades) {
                        ctx.strokeStyle = grass.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(grass.x, grass.y + 5);
                        ctx.quadraticCurveTo(grass.x + grass.lean * grass.height, grass.y + 2, 
                                           grass.x + grass.lean * grass.height, grass.y - grass.height);
                        ctx.stroke();
                    }
                    
                    // Draw depth layers
                    const depthLayers = [
                        { depth: 0.0, color: '#4A2C17', alpha: 0.9 },
                        { depth: 0.15, color: '#3A1F0F', alpha: 0.95 },
                        { depth: 0.35, color: '#2A1509', alpha: 0.98 },
                        { depth: 0.6, color: '#1A0A04', alpha: 1.0 },
                        { depth: 0.85, color: '#000000', alpha: 1.0 }
                    ];
                    
                    for (let layer of depthLayers) {
                        const layerGradient = ctx.createRadialGradient(
                            centerX, centerY - layer.depth * 5, 0,
                            centerX, centerY - layer.depth * 5, baseRadius * (1.0 - layer.depth * 0.3)
                        );
                        layerGradient.addColorStop(0, layer.color);
                        layerGradient.addColorStop(0.6, layer.color);
                        layerGradient.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        ctx.save();
                        ctx.globalAlpha = layer.alpha;
                        ctx.fillStyle = layerGradient;
                        ctx.beginPath();
                        ctx.moveTo(centerX + hole.irregularPoints[0].radius * (1.0 - layer.depth * 0.3) * Math.cos(hole.irregularPoints[0].angle), 
                                  centerY + hole.irregularPoints[0].radius * (1.0 - layer.depth * 0.3) * Math.sin(hole.irregularPoints[0].angle));
                        for (let i = 1; i < hole.irregularPoints.length; i++) {
                            const point = hole.irregularPoints[i];
                            const layerRadius = point.radius * (1.0 - layer.depth * 0.3);
                            ctx.lineTo(centerX + layerRadius * Math.cos(point.angle), 
                                      centerY + layerRadius * Math.sin(point.angle));
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // Add some moisture/dampness effect at the bottom
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const moistureGradient = ctx.createRadialGradient(
                        centerX, centerY + baseRadius * 0.3, 0,
                        centerX, centerY + baseRadius * 0.3, baseRadius * 0.4
                    );
                    moistureGradient.addColorStop(0, '#001122');
                    moistureGradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = moistureGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY + baseRadius * 0.3, baseRadius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }

        function drawGround() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            const groundGradient = ctx.createLinearGradient(0, 340, 0, 400);
            groundGradient.addColorStop(0, '#32CD32');
            groundGradient.addColorStop(0.2, '#228B22');
            groundGradient.addColorStop(0.6, '#1E7B1E');
            groundGradient.addColorStop(1, '#0F5F0F');
            
            ctx.fillStyle = groundGradient;
            ctx.fillRect(-200, 340, canvas.width + game.camera.x + 400, 60);
            
            for (let i = 0; i < 200; i++) {
                const x = -200 + i * 20 + (game.camera.x * 0.1);
                const grassHeight = 3 + Math.sin(i * 0.5) * 2;
                const grassColor = i % 3 === 0 ? '#228B22' : i % 3 === 1 ? '#32CD32' : '#2E8B57';
                
                if (x > game.camera.x - 50 && x < game.camera.x + canvas.width + 50) {
                    ctx.fillStyle = grassColor;
                    ctx.fillRect(x, 340 - grassHeight, 1, grassHeight);
                    ctx.fillRect(x + 2, 340 - grassHeight + 1, 1, grassHeight - 1);
                    ctx.fillRect(x + 4, 340 - grassHeight + 0.5, 1, grassHeight - 0.5);
                }
            }
            
            ctx.restore();
        }

        function drawFlowers() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            for (let flower of game.flowers) {
                if (flower.x > game.camera.x - 20 && flower.x < game.camera.x + canvas.width + 20) {
                    const swayOffset = Math.sin(flower.swayPhase) * 2;
                    
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(flower.x, flower.y + 10);
                    ctx.quadraticCurveTo(flower.x + swayOffset/2, flower.y + 6, flower.x + swayOffset, flower.y);
                    ctx.stroke();
                    
                    const gradient = ctx.createRadialGradient(
                        flower.x + swayOffset, flower.y, 0,
                        flower.x + swayOffset, flower.y, flower.size * 0.8
                    );
                    gradient.addColorStop(0, flower.color);
                    gradient.addColorStop(0.7, flower.color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                    
                    ctx.fillStyle = gradient;
                    ctx.save();
                    ctx.translate(flower.x + swayOffset, flower.y);
                    
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + flower.swayPhase * 0.1;
                        ctx.save();
                        ctx.rotate(angle);
                        
                        ctx.beginPath();
                        ctx.ellipse(0, -flower.size * 0.7, flower.size * 0.4, flower.size * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const petalGradient = ctx.createRadialGradient(0, -flower.size * 0.4, 0, 0, -flower.size * 0.4, flower.size * 0.3);
                        petalGradient.addColorStop(0, 'rgba(255,255,255,0.3)');
                        petalGradient.addColorStop(1, 'rgba(255,255,255,0)');
                        ctx.fillStyle = petalGradient;
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, flower.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FFA500';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const dotX = Math.cos(angle) * flower.size * 0.15;
                        const dotY = Math.sin(angle) * flower.size * 0.15;
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#228B22';
                    ctx.save();
                    ctx.rotate(-Math.PI/4 + swayOffset * 0.1);
                    ctx.beginPath();
                    ctx.ellipse(-flower.size * 0.5, -flower.size * 0.3, flower.size * 0.2, flower.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.rotate(Math.PI/4 + swayOffset * 0.1);
                    ctx.beginPath();
                    ctx.ellipse(flower.size * 0.6, -flower.size * 0.2, flower.size * 0.15, flower.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }

        function drawSky() {
            const sunX = 700;
            const sunY = 60;
            
            const gradient = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 50);
            gradient.addColorStop(0, '#FFFF99');
            gradient.addColorStop(0.3, '#FFD700');
            gradient.addColorStop(0.7, '#FFA500');
            gradient.addColorStop(1, 'rgba(255,165,0,0.3)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(sunX, sunY, 50, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFF99';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const startX = sunX + Math.cos(angle) * 35;
                const startY = sunY + Math.sin(angle) * 35;
                const endX = sunX + Math.cos(angle) * 55;
                const endY = sunY + Math.sin(angle) * 55;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }

        function drawMountains() {
            for (let mountain of game.mountains) {
                if (mountain.x + mountain.width > -100 && 
                    mountain.x < canvas.width + 100) {
                    
                    const gradient = ctx.createLinearGradient(0, mountain.y, 0, canvas.height);
                    gradient.addColorStop(0, mountain.color);
                    gradient.addColorStop(0.4, mountain.color);
                    gradient.addColorStop(1, '#5D4E37');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(mountain.x, canvas.height);
                    
                    if (!mountain.peakX) {
                        mountain.peakX = mountain.x + mountain.width/2 + (Math.random() - 0.5) * 40;
                    }
                    const peakX = mountain.peakX;
                    
                    ctx.lineTo(mountain.x + mountain.width * 0.2, mountain.y + mountain.height * 0.3);
                    ctx.lineTo(mountain.x + mountain.width * 0.4, mountain.y + mountain.height * 0.1);
                    ctx.lineTo(peakX, mountain.y);
                    ctx.lineTo(mountain.x + mountain.width * 0.6, mountain.y + mountain.height * 0.15);
                    ctx.lineTo(mountain.x + mountain.width * 0.8, mountain.y + mountain.height * 0.4);
                    ctx.lineTo(mountain.x + mountain.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.moveTo(peakX - 25, mountain.y + 15);
                    ctx.lineTo(peakX, mountain.y);
                    ctx.lineTo(peakX + 20, mountain.y + 12);
                    ctx.lineTo(peakX + 15, mountain.y + 25);
                    ctx.lineTo(peakX - 20, mountain.y + 30);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.moveTo(peakX, mountain.y);
                    ctx.lineTo(mountain.x + mountain.width * 0.6, mountain.y + mountain.height * 0.15);
                    ctx.lineTo(mountain.x + mountain.width * 0.8, mountain.y + mountain.height * 0.4);
                    ctx.lineTo(mountain.x + mountain.width, canvas.height);
                    ctx.lineTo(peakX + 20, mountain.y + 12);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }


        function drawClouds() {
            ctx.save();
            ctx.translate(-game.camera.x * 0.3, 0);
            
            for (let cloud of game.clouds) {
                if (cloud.x + cloud.width > game.camera.x * 0.3 && 
                    cloud.x < game.camera.x * 0.3 + canvas.width) {
                    
                    const gradient = ctx.createRadialGradient(
                        cloud.x + cloud.width/2, cloud.y, 0,
                        cloud.x + cloud.width/2, cloud.y + 10, cloud.width/2
                    );
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.7, '#F0F8FF');
                    gradient.addColorStop(1, '#E0E6E8');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    
                    const bubbles = [
                        {x: cloud.x + cloud.width * 0.1, y: cloud.y + 5, r: cloud.height/3},
                        {x: cloud.x + cloud.width * 0.25, y: cloud.y - 2, r: cloud.height/2.2},
                        {x: cloud.x + cloud.width * 0.45, y: cloud.y - 5, r: cloud.height/1.8},
                        {x: cloud.x + cloud.width * 0.6, y: cloud.y - 3, r: cloud.height/2.1},
                        {x: cloud.x + cloud.width * 0.75, y: cloud.y + 2, r: cloud.height/2.5},
                        {x: cloud.x + cloud.width * 0.9, y: cloud.y + 8, r: cloud.height/3.2}
                    ];
                    
                    for (let bubble of bubbles) {
                        ctx.arc(bubble.x, bubble.y, bubble.r, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(200,220,230,0.3)';
                    ctx.beginPath();
                    for (let i = 2; i < bubbles.length; i++) {
                        let bubble = bubbles[i];
                        ctx.arc(bubble.x + 3, bubble.y + 5, bubble.r * 0.7, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        function drawButterflies() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            for (let butterfly of game.butterflies) {
                if (butterfly.x > game.camera.x - 50 && butterfly.x < game.camera.x + canvas.width + 50) {
                    const wingFlap = Math.abs(Math.sin(butterfly.wingPhase)) * 0.8 + 0.2;
                    const wingRotation = Math.sin(butterfly.wingPhase) * 0.3;
                    
                    ctx.save();
                    ctx.translate(butterfly.x, butterfly.y);
                    
                    ctx.fillStyle = butterfly.color;
                    ctx.globalAlpha = 0.8;
                    
                    ctx.save();
                    ctx.scale(wingFlap, 1);
                    ctx.rotate(-wingRotation);
                    ctx.beginPath();
                    ctx.arc(-6, -4, 4, 0, Math.PI * 2);
                    ctx.arc(-8, -1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.scale(wingFlap, 1);
                    ctx.rotate(wingRotation);
                    ctx.beginPath();
                    ctx.arc(6, -4, 4, 0, Math.PI * 2);
                    ctx.arc(8, -1, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.scale(wingFlap, 1);
                    ctx.rotate(-wingRotation * 0.7);
                    ctx.fillStyle = '#FFB6C1';
                    ctx.beginPath();
                    ctx.arc(-5, 1, 3, 0, Math.PI * 2);
                    ctx.arc(-7, 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.scale(wingFlap, 1);
                    ctx.rotate(wingRotation * 0.7);
                    ctx.fillStyle = '#FFB6C1';
                    ctx.beginPath();
                    ctx.arc(5, 1, 3, 0, Math.PI * 2);
                    ctx.arc(7, 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(0, 0, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -2);
                    ctx.lineTo(0, 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-1, -5, 0.5, 0, Math.PI * 2);
                    ctx.arc(1, -5, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }

        function drawBees() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);
            
            for (let bee of game.bees) {
                if (bee.x > game.camera.x - 50 && bee.x < game.camera.x + canvas.width + 50) {
                    const wingFlap = Math.abs(Math.sin(bee.wingPhase)) * 0.5 + 0.5;
                    
                    ctx.save();
                    ctx.translate(bee.x, bee.y);
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-1, -2, 2, 1);
                    ctx.fillRect(-1, 0, 2, 1);
                    ctx.fillRect(-1, 2, 2, 1);
                    
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.save();
                    ctx.scale(1, wingFlap);
                    ctx.beginPath();
                    ctx.arc(-4, -2, 2, 0, Math.PI * 2);
                    ctx.arc(4, -2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-1, -4, 0.5, 0, Math.PI * 2);
                    ctx.arc(1, -4, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-2, -4);
                    ctx.lineTo(-3, -5);
                    ctx.moveTo(2, -4);
                    ctx.lineTo(3, -5);
                    ctx.stroke();
                    
                    if (bee.targetFlower) {
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(bee.targetFlower.x - bee.x, bee.targetFlower.y - bee.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    ctx.restore();
                }
            }
            
            ctx.restore();
        }

        function drawBeetles() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);

            for (let beetle of game.beetles) {
                if (beetle.x > game.camera.x - 50 && beetle.x < game.camera.x + canvas.width + 50) {
                    const x = beetle.x;
                    const y = beetle.y;
                    const w = beetle.width;
                    const h = beetle.height;
                    const legOffset = Math.sin(beetle.legPhase) * 3;

                    // Beetle shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(x + w/2, y + h + 2, w/2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Beetle body - main shell
                    const bodyGradient = ctx.createRadialGradient(
                        x + w/2, y + h/3, 0,
                        x + w/2, y + h/2, w/2
                    );
                    bodyGradient.addColorStop(0, '#8B4513');
                    bodyGradient.addColorStop(0.5, '#654321');
                    bodyGradient.addColorStop(1, '#3A2817');

                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.ellipse(x + w/2, y + h/2, w/2.2, h/2.2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Shell division line
                    ctx.strokeStyle = '#2A1810';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + w/2, y);
                    ctx.lineTo(x + w/2, y + h);
                    ctx.stroke();

                    // Shell spots
                    ctx.fillStyle = '#4A2817';
                    const spots = [
                        {x: x + w * 0.3, y: y + h * 0.3, r: 2},
                        {x: x + w * 0.7, y: y + h * 0.3, r: 2},
                        {x: x + w * 0.25, y: y + h * 0.6, r: 1.5},
                        {x: x + w * 0.75, y: y + h * 0.6, r: 1.5}
                    ];
                    for (let spot of spots) {
                        ctx.beginPath();
                        ctx.arc(spot.x, spot.y, spot.r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Head
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    if (beetle.direction === 1) {
                        ctx.ellipse(x + w - 5, y + h/2, 8, 6, 0, 0, Math.PI * 2);
                    } else {
                        ctx.ellipse(x + 5, y + h/2, 8, 6, 0, 0, Math.PI * 2);
                    }
                    ctx.fill();

                    // Eyes
                    ctx.fillStyle = '#FF0000';
                    if (beetle.direction === 1) {
                        ctx.beginPath();
                        ctx.arc(x + w - 3, y + h/2 - 2, 1.5, 0, Math.PI * 2);
                        ctx.arc(x + w - 3, y + h/2 + 2, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(x + 3, y + h/2 - 2, 1.5, 0, Math.PI * 2);
                        ctx.arc(x + 3, y + h/2 + 2, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Antennae
                    ctx.strokeStyle = '#4A2817';
                    ctx.lineWidth = 1.5;
                    if (beetle.direction === 1) {
                        ctx.beginPath();
                        ctx.moveTo(x + w - 5, y + h/2 - 4);
                        ctx.lineTo(x + w + 2, y + h/2 - 8);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x + w - 5, y + h/2 + 4);
                        ctx.lineTo(x + w + 2, y + h/2 + 8);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(x + 5, y + h/2 - 4);
                        ctx.lineTo(x - 2, y + h/2 - 8);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x + 5, y + h/2 + 4);
                        ctx.lineTo(x - 2, y + h/2 + 8);
                        ctx.stroke();
                    }

                    // Legs (6 legs - 3 on each side)
                    ctx.strokeStyle = '#3A2817';
                    ctx.lineWidth = 2;

                    // Left side legs
                    for (let i = 0; i < 3; i++) {
                        const legX = x + w * (0.25 + i * 0.25);
                        const legY = y + h;
                        const offset = (i % 2 === 0) ? legOffset : -legOffset;

                        ctx.beginPath();
                        ctx.moveTo(legX, legY);
                        ctx.lineTo(legX - 6, legY + 8 + offset);
                        ctx.stroke();
                    }

                    // Right side legs
                    for (let i = 0; i < 3; i++) {
                        const legX = x + w * (0.25 + i * 0.25);
                        const legY = y + h;
                        const offset = (i % 2 === 0) ? -legOffset : legOffset;

                        ctx.beginPath();
                        ctx.moveTo(legX, legY);
                        ctx.lineTo(legX + 6, legY + 8 + offset);
                        ctx.stroke();
                    }

                    // Highlight on shell
                    ctx.fillStyle = 'rgba(139, 90, 43, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(x + w/2, y + h/3, w/3, h/4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawSpiders() {
            ctx.save();
            ctx.translate(-game.camera.x, 0);

            for (let spider of game.spiders) {
                if (spider.x > game.camera.x - 50 && spider.x < game.camera.x + canvas.width + 50) {
                    const x = spider.x;
                    const y = spider.y;
                    const w = spider.width;
                    const h = spider.height;

                    // Spider web/thread
                    if (spider.webLength > 0) {
                        ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, 50);
                        ctx.lineTo(x, y);
                        ctx.stroke();

                        // Web shine effect
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(x - 1, 50);
                        ctx.lineTo(x - 1, y);
                        ctx.stroke();
                    }

                    // Spider shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(x, 340, w/2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Spider body
                    const bodyGradient = ctx.createRadialGradient(x, y, 0, x, y, w/2);
                    bodyGradient.addColorStop(0, '#2F2F2F');
                    bodyGradient.addColorStop(0.6, '#1A1A1A');
                    bodyGradient.addColorStop(1, '#000000');

                    // Abdomen (back part)
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.ellipse(x, y + 3, w/2.5, h/2.2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Cephalothorax (front part)
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.ellipse(x, y - 3, w/3, h/3, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Spider legs (8 legs - 4 on each side)
                    ctx.strokeStyle = '#1A1A1A';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';

                    const legAnimation = Math.sin(spider.state === 'dropping' || spider.state === 'rising' ? Date.now() * 0.01 : 0);

                    for (let i = 0; i < 4; i++) {
                        const legY = y - 5 + (i * 4);
                        const legLength = w/2 + 4;
                        const legBend = 8;
                        const wiggle = legAnimation * 2;

                        // Left legs
                        ctx.beginPath();
                        ctx.moveTo(x - 4, legY);
                        ctx.lineTo(x - legLength/2 - wiggle, legY - legBend);
                        ctx.lineTo(x - legLength - wiggle, legY - legBend/2);
                        ctx.stroke();

                        // Right legs
                        ctx.beginPath();
                        ctx.moveTo(x + 4, legY);
                        ctx.lineTo(x + legLength/2 + wiggle, legY - legBend);
                        ctx.lineTo(x + legLength + wiggle, legY - legBend/2);
                        ctx.stroke();
                    }

                    // Eyes (multiple small eyes)
                    ctx.fillStyle = '#FF0000';
                    const eyePositions = [
                        {x: x - 3, y: y - 5},
                        {x: x - 1, y: y - 6},
                        {x: x + 1, y: y - 6},
                        {x: x + 3, y: y - 5}
                    ];
                    for (let eye of eyePositions) {
                        ctx.beginPath();
                        ctx.arc(eye.x, eye.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Fangs (small)
                    ctx.strokeStyle = '#FFE5B4';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - 2, y - 2);
                    ctx.lineTo(x - 3, y + 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + 2, y - 2);
                    ctx.lineTo(x + 3, y + 2);
                    ctx.stroke();

                    // Highlight on body
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(x - 2, y + 1, w/6, h/6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawPortal() {
            if (!game.portal) return;

            ctx.save();
            ctx.translate(-game.camera.x, 0);

            if (game.portal.x > game.camera.x - 100 && game.portal.x < game.camera.x + canvas.width + 100) {
                const x = game.portal.x;
                const y = game.portal.y;
                const w = game.portal.width;
                const h = game.portal.height;
                const phase = game.portalAnimationPhase;

                // Ground platform for portal
                const platformGradient = ctx.createLinearGradient(0, y + h, 0, y + h + 20);
                platformGradient.addColorStop(0, '#696969');
                platformGradient.addColorStop(1, '#3A3A3A');
                ctx.fillStyle = platformGradient;
                ctx.fillRect(x - 20, y + h, w + 40, 20);

                // Stone base
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(x - 15, y + h, 15, 15);
                ctx.fillRect(x + w, y + h, 15, 15);

                // Draw stone pillars with texture
                for (let side = 0; side < 2; side++) {
                    const pillarX = side === 0 ? x - 12 : x + w + 2;

                    // Pillar gradient
                    const pillarGradient = ctx.createLinearGradient(pillarX, y, pillarX + 10, y);
                    pillarGradient.addColorStop(0, '#5A5A5A');
                    pillarGradient.addColorStop(0.5, '#6A6A6A');
                    pillarGradient.addColorStop(1, '#4A4A4A');

                    ctx.fillStyle = pillarGradient;
                    ctx.fillRect(pillarX, y + 10, 10, h - 10);

                    // Stone brick lines
                    ctx.strokeStyle = '#3A3A3A';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 5; i++) {
                        const brickY = y + 10 + (i * (h - 10) / 5);
                        ctx.beginPath();
                        ctx.moveTo(pillarX, brickY);
                        ctx.lineTo(pillarX + 10, brickY);
                        ctx.stroke();
                    }

                    // Pillar capital (top decoration)
                    ctx.fillStyle = '#6A6A6A';
                    ctx.fillRect(pillarX - 3, y + 5, 16, 5);
                    ctx.fillRect(pillarX - 2, y, 14, 5);
                }

                // Top arch with depth
                ctx.lineWidth = 12;
                ctx.strokeStyle = '#5A5A5A';
                ctx.beginPath();
                ctx.arc(x + w/2, y + 10, w/2 + 8, Math.PI, 0, false);
                ctx.stroke();

                // Arch inner shadow
                ctx.lineWidth = 8;
                ctx.strokeStyle = '#4A4A4A';
                ctx.beginPath();
                ctx.arc(x + w/2, y + 10, w/2 + 8, Math.PI, 0, false);
                ctx.stroke();

                // Arch highlight
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#7A7A7A';
                ctx.beginPath();
                ctx.arc(x + w/2, y + 10, w/2 + 4, Math.PI + 0.5, Math.PI * 2 - 0.5, false);
                ctx.stroke();

                // Ancient runes on arch
                ctx.fillStyle = '#FFD700';
                ctx.font = '12px serif';
                ctx.textAlign = 'center';
                const runes = ['‚óá', '‚óÜ', '‚óà', '‚óá'];
                for (let i = 0; i < runes.length; i++) {
                    const runeAngle = Math.PI + (i / (runes.length - 1)) * Math.PI;
                    const runeX = x + w/2 + Math.cos(runeAngle) * (w/2 + 5);
                    const runeY = y + 10 + Math.sin(runeAngle) * (w/2 + 5);
                    ctx.fillText(runes[i], runeX, runeY);
                }

                // Outer energy glow (pulsating)
                const pulseIntensity = Math.sin(phase * 2) * 0.3 + 0.7;
                const outerGlow = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, w * 0.8);
                outerGlow.addColorStop(0, `rgba(138, 43, 226, ${0.4 * pulseIntensity})`);
                outerGlow.addColorStop(0.5, `rgba(75, 0, 130, ${0.2 * pulseIntensity})`);
                outerGlow.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.ellipse(x + w/2, y + h/2, w * 0.8, h * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Portal interior - dark center with energy
                const portalGradient = ctx.createRadialGradient(
                    x + w/2, y + h/2, 0,
                    x + w/2, y + h/2, w/2
                );
                portalGradient.addColorStop(0, '#000033');
                portalGradient.addColorStop(0.3, '#1a0066');
                portalGradient.addColorStop(0.6, '#4B0082');
                portalGradient.addColorStop(0.85, '#8A2BE2');
                portalGradient.addColorStop(1, '#9370DB');

                ctx.fillStyle = portalGradient;
                ctx.beginPath();
                ctx.ellipse(x + w/2, y + h/2 + 5, w/2 - 5, h/2 - 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Spiral energy streams
                for (let stream = 0; stream < 3; stream++) {
                    ctx.strokeStyle = `rgba(138, 43, 226, ${0.6 - stream * 0.15})`;
                    ctx.lineWidth = 3 - stream;
                    ctx.beginPath();

                    for (let i = 0; i < 50; i++) {
                        const t = i / 50;
                        const angle = t * Math.PI * 4 + phase * (stream + 1) + stream * Math.PI * 2/3;
                        const radius = (1 - t) * (w/2 - 10);
                        const px = x + w/2 + Math.cos(angle) * radius;
                        const py = y + h/2 + 5 + Math.sin(angle) * radius * (h/w);

                        if (i === 0) {
                            ctx.moveTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }
                    ctx.stroke();
                }

                // Energy particles floating
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2 + phase * 1.5;
                    const radius = (Math.sin(phase * 3 + i * 0.5) * 0.3 + 0.5) * (w/2 - 10);
                    const px = x + w/2 + Math.cos(angle) * radius;
                    const py = y + h/2 + 5 + Math.sin(angle) * radius * (h/w);

                    const particleSize = Math.sin(phase * 4 + i) * 1.5 + 2;
                    const particleAlpha = Math.sin(phase * 2 + i) * 0.4 + 0.6;

                    const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, particleSize);
                    particleGradient.addColorStop(0, `rgba(200, 150, 255, ${particleAlpha})`);
                    particleGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');

                    ctx.fillStyle = particleGradient;
                    ctx.beginPath();
                    ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center bright vortex
                const vortexGradient = ctx.createRadialGradient(
                    x + w/2, y + h/2 + 5, 0,
                    x + w/2, y + h/2 + 5, w/6
                );
                vortexGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulseIntensity})`);
                vortexGradient.addColorStop(0.3, `rgba(200, 150, 255, ${0.7 * pulseIntensity})`);
                vortexGradient.addColorStop(0.7, `rgba(138, 43, 226, ${0.3 * pulseIntensity})`);
                vortexGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');

                ctx.fillStyle = vortexGradient;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2 + 5, w/6, 0, Math.PI * 2);
                ctx.fill();

                // Lightning/energy bolts occasionally
                if (Math.sin(phase * 5) > 0.8) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.8})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#8A2BE2';

                    for (let bolt = 0; bolt < 3; bolt++) {
                        const boltAngle = (bolt / 3) * Math.PI * 2 + phase;
                        ctx.beginPath();
                        ctx.moveTo(x + w/2, y + h/2 + 5);
                        const endX = x + w/2 + Math.cos(boltAngle) * (w/2 - 15);
                        const endY = y + h/2 + 5 + Math.sin(boltAngle) * (h/2 - 15);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }

                    ctx.shadowBlur = 0;
                }

                // Portal label
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 16px serif';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#000';
                ctx.fillText('PORTAL', x + w/2, y - 25);

                if (game.level < 4) {
                    ctx.font = '12px serif';
                    ctx.fillStyle = '#FFF';
                    ctx.fillText(`‚Üí Poziom ${game.level + 1}`, x + w/2, y - 8);
                } else {
                    ctx.font = '12px serif';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText('KONIEC', x + w/2, y - 8);
                }

                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function drawSkyGradient() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.3, '#98D8E8');
            gradient.addColorStop(0.7, '#B0E0E6');
            gradient.addColorStop(1, '#E0F6FF');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawLives() {
            // Draw hearts for lives
            for (let i = 0; i < game.lives; i++) {
                const x = 10 + i * 35;
                const y = 25;

                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(x + 10, y + 8);

                // Left half of heart
                ctx.bezierCurveTo(x + 10, y + 5, x + 5, y, x + 5, y);
                ctx.bezierCurveTo(x, y, x, y + 5, x, y + 8);
                ctx.bezierCurveTo(x, y + 11, x + 5, y + 14, x + 10, y + 18);

                // Right half of heart
                ctx.bezierCurveTo(x + 15, y + 14, x + 20, y + 11, x + 20, y + 8);
                ctx.bezierCurveTo(x + 20, y + 5, x + 20, y, x + 15, y);
                ctx.bezierCurveTo(x + 15, y, x + 10, y + 5, x + 10, y + 8);

                ctx.closePath();
                ctx.fill();

                // Heart shine effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(x + 7, y + 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw empty hearts for lost lives
            for (let i = game.lives; i < 3; i++) {
                const x = 10 + i * 35;
                const y = 25;

                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 10, y + 8);

                ctx.bezierCurveTo(x + 10, y + 5, x + 5, y, x + 5, y);
                ctx.bezierCurveTo(x, y, x, y + 5, x, y + 8);
                ctx.bezierCurveTo(x, y + 11, x + 5, y + 14, x + 10, y + 18);

                ctx.bezierCurveTo(x + 15, y + 14, x + 20, y + 11, x + 20, y + 8);
                ctx.bezierCurveTo(x + 20, y + 5, x + 20, y, x + 15, y);
                ctx.bezierCurveTo(x + 15, y, x + 10, y + 5, x + 10, y + 8);

                ctx.closePath();
                ctx.stroke();
            }
        }

        function draw() {
            drawSkyGradient();

            drawSky();
            drawMountains();
            drawClouds();
            drawSpiders();
            drawButterflies();
            drawBees();
            drawGround();
            drawFlowers();
            drawObstacles();
            drawPortal();
            drawPlayer();

            drawLives();

            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.fillText(`Pozycja: ${Math.floor(game.player.x)}`, 10, 60);
            ctx.fillText(`Poziom: ${game.level}`, canvas.width - 100, 30);
        }

        function gameLoop() {
            if (game.started) {
                updatePlayer();
                updateCamera();
                checkCollisions();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (game.started) {
                game.keys[e.key] = true;
                game.keys[e.code] = true; // Also store by key code
            }
        });

        document.addEventListener('keyup', (e) => {
            if (game.started) {
                game.keys[e.key] = false;
                game.keys[e.code] = false; // Also clear by key code
            }
        });

        document.getElementById('playButton').addEventListener('click', () => {
            game.started = true;
            document.getElementById('menu').classList.add('hidden');
            document.querySelector('.controls').style.display = 'block';
        });

        gameLoop();
    </script>
</body>
</html>